drop policy "Enable delete for users based on user_id" on "public"."profile";

drop policy "Enable insert for authenticated users only" on "public"."profile";

drop policy "can_update_own_data" on "public"."profile";

drop policy "anon_auth_del" on "public"."roles";

drop policy "anon_auth_insert" on "public"."roles";

drop policy "anon_auth_update" on "public"."roles";

create table "public"."driver_updates" (
    "id" uuid not null default gen_random_uuid(),
    "datetime" timestamp without time zone not null,
    "lat" double precision,
    "long" double precision,
    "drv" uuid,
    "log_number" bigint
);


alter table "public"."driver_updates" enable row level security;

create table "public"."user_search" (
    "id" bigint generated by default as identity not null,
    "datetime" timestamp without time zone not null,
    "lat" double precision,
    "long" double precision,
    "credit" smallint,
    "destination" text,
    "identifier" uuid
);


alter table "public"."user_search" enable row level security;

alter table "public"."driverlogs" alter column "driver_id" set not null;

alter table "public"."driverlogs" alter column "endtime" set not null;

alter table "public"."driverlogs" alter column "latEnd" set not null;

alter table "public"."driverlogs" alter column "latStart" set not null;

alter table "public"."driverlogs" alter column "longEnd" set not null;

alter table "public"."driverlogs" alter column "starttime" set not null;

alter table "public"."profile" add column "identifier" uuid;

CREATE UNIQUE INDEX driver_updates_pkey ON public.driver_updates USING btree (id);

CREATE UNIQUE INDEX user_search_pkey ON public.user_search USING btree (id);

alter table "public"."driver_updates" add constraint "driver_updates_pkey" PRIMARY KEY using index "driver_updates_pkey";

alter table "public"."user_search" add constraint "user_search_pkey" PRIMARY KEY using index "user_search_pkey";

alter table "public"."driver_updates" add constraint "driver_updates_drv_fkey" FOREIGN KEY (drv) REFERENCES auth.users(id) ON UPDATE CASCADE not valid;

alter table "public"."driver_updates" validate constraint "driver_updates_drv_fkey";

alter table "public"."driver_updates" add constraint "driver_updates_log_number_fkey" FOREIGN KEY (log_number) REFERENCES driverlogs(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid;

alter table "public"."driver_updates" validate constraint "driver_updates_log_number_fkey";

alter table "public"."driverlogs" add constraint "driverlogs_driver_id_fkey" FOREIGN KEY (driver_id) REFERENCES auth.users(id) ON UPDATE CASCADE not valid;

alter table "public"."driverlogs" validate constraint "driverlogs_driver_id_fkey";

alter table "public"."user_search" add constraint "user_search_destination_fkey" FOREIGN KEY (destination) REFERENCES nodescode(code) ON UPDATE CASCADE not valid;

alter table "public"."user_search" validate constraint "user_search_destination_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.drv_min(lat real, long real, upd_tme timestamp without time zone, spd integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE 
	origin_count INT; 
	destination_count INT;
	average_distance double precision;
	segment_var text[];
  user_uuid uuid;
BEGIN
if public.check_is_driver()=false then
	raise EXCEPTION 'Unauthorized';
end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)

	select
	 	FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS segment_var
	into
		average_distance, 
		origin_count, 
		destination_count,
		segment_var
	FROM distance_from_origin_table;
	
	IF origin_count = 1 AND destination_count = 1 THEN 
		UPDATE public.pasada 
		SET segment = segment_var
		WHERE driver =( SELECT auth.uid() AS uid);
	end if;
	UPDATE public.pasada 
	SET segment_distance =  average_distance,time=upd_tme,
	latitude= lat,longitude=long,speed=spd
	WHERE driver = ( SELECT auth.uid() AS uid);
	select auth.id()as user_uuid;
	Insert into public.driver_updates ("datetime","lat","long","drv")
	values(upd_tme,lat,long,user_uuid);
END;$function$
;

CREATE OR REPLACE FUNCTION public.q_drivers(lat real, long real, dest text)
 RETURNS TABLE(driver_id text, type text, speed smallint, user_driver_distance double precision, eta integer)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE 
	query_time timestamp:=now()::timestamp;
	origin_count INT;
	destination_count INT;
	average_user_distance real;
	user_segment_array TEXT[];
	data_record record;
	user_total_segment_distance real;
	credit int;
	query_identifier uuid;
BEGIN
	if (public.check_is_admin() or public.check_is_driver() or public.update_daily_credit())=false then
		raise EXCEPTION 'Unauthorized.';
	end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)
	select
		FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS user_segment_array
	INTO
		average_user_distance,
		origin_count,
		destination_count,
		user_segment_array
	FROM distance_from_origin_table;

	select distance 
	from public.distancetable 
	where (start_node = any(user_segment_array) and end_node = any(user_segment_array)) into user_total_segment_distance;

	select code 
	from public.nodescode 
	where nodes=dest into dest;

	select daily_credits,identifier 
	into credit,query_identifier
	from public.profile
	where((SELECT auth.uid() AS uid)=profile.id);

	insert into public.user_search("datetime","lat","long","credit","destination","identifier")
	values(
		query_time,lat,long,credit+1,dest,query_identifier
	);
	
	return query	
	with initial_table as(
		SELECT p.driver,p.speed,is_reversed_route,p.segment as current_segment,
			public.distancetable.distance as total_segment_distance,-- driver
			query_time-p.time as time_active,
			floor
				(
				(1000*(p.speed) * (EXTRACT(EPOCH FROM (query_time-p.time)) / 3600))+
				p.segment_distance
			) as extrapolated_distance,--driver distance traveled with time queried and driver-time_updated
			array[r.origin]||r.route|| array[r.destination] as complete_driver_routes,--routes of driver from origin to destination
			-- string_to_array(segment,',') as current_segment--current segment of driver
			p.v_type
		FROM public.pasada p
		inner join  public.route_table r on p.driver_route= r.id
		inner join public.distancetable on p.segment = array[public.distancetable.start_node]||array[public.distancetable.end_node]
	),
	segments_table as(
		select *,
			array_position(complete_driver_routes,current_segment[1]) as pos_current_segment_one,--leg segment of driver starting
			array_position(complete_driver_routes,current_segment[2]) as pos_current_segment_two,--leg segment of driver ending
			array_position(complete_driver_routes,user_segment_array[1]) as pos_user_segment_one,--leg segment of user starting
			array_position(complete_driver_routes,user_segment_array[2]) as pos_user_segment_two,--leg segment of user ending
			array_position(complete_driver_routes,dest) as pos_user_destination--position of user destination
		from initial_table
		where (
			dest =any(complete_driver_routes)
			and time_active<interval '30 minutes'
			and time_active>interval '-30 minutes'
			and user_segment_array<@complete_driver_routes --user segment in complete driver route
		)
	),
	filtered_table as(
		select*
		from
			segments_table
		where (complete_driver_routes[1]=any(user_segment_array) and complete_driver_routes[array_length(complete_driver_routes, 1)]=any(user_segment_array) --same segment for both user and driver 
			and case
				when is_reversed_route=true 
					and dest= complete_driver_routes[1] and average_user_distance<segments_table.extrapolated_distance
				then 1
				when is_reversed_route=false 
				and dest = complete_driver_routes[array_length(complete_driver_routes, 1)] and average_user_distance>segments_table.extrapolated_distance
				then 1
				else 0
			end= 1
			) or
			(
				-- (
				-- dest = any(complete_driver_routes) --user destination in complete driver route
				-- and current_segment is not null
			case
				when is_reversed_route=false  --driver to lagawe, user to lagawe
					and dest= any(complete_driver_routes[greatest(pos_user_segment_two,pos_current_segment_two):])
					and case
						when pos_user_destination=pos_current_segment_two 
							and average_user_distance<segments_table.extrapolated_distance
						then 0
						else 1
					end =1
				then 1
				when is_reversed_route=true --driver to banaue user to banaue
					and dest= any(complete_driver_routes[:least(pos_user_segment_one,pos_current_segment_one)])
					and pos_current_segment_one-pos_user_segment_two>1
					and case
						when pos_user_destination=pos_current_segment_one 
							and average_user_distance>segments_table.extrapolated_distance
						then 0
						else 1
					end=1
				then 1
				else 0
			end =1
		)
	),
	-- calculate the distance and eta, segment considered
	user_driver_distance_table as(
		select driver,filtered_table.speed,filtered_table.extrapolated_distance, average_user_distance,filtered_table.v_type,
			case
				when pos_user_segment_one=pos_current_segment_one 
				then floor(abs(average_user_distance-filtered_table.extrapolated_distance)) --same segment
				when pos_user_segment_one-pos_current_segment_one=1
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance)) --adjacent segment
				when pos_user_segment_one-pos_current_segment_one>1 
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance))+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				when pos_current_segment_one-pos_user_segment_one=1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance) --adjacent segment
				when pos_current_segment_one-pos_user_segment_one>1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance)+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				-- else 0
			end as user_driver_distance
		from filtered_table
	),
	eta_calculations as(
		select *,
			floor(((user_driver_distance_table.user_driver_distance/1000)/user_driver_distance_table.speed)*60)::integer as eta
		from user_driver_distance_table
		ORDER BY eta
	),
  user_tables as(
    select COALESCE(p.username, 'Mr.Driver') AS driver_name, 
    v.type, 
		e.speed, 
		e.user_driver_distance, 
		e.eta
    from eta_calculations e
    inner join public.profile p on e.driver=p.id
		inner join public.v_types v on e.v_type = v.id
  )
	SELECT *
	FROM user_tables;
END;$function$
;

CREATE OR REPLACE FUNCTION public.q_drivers2(lat real, long real, dest text)
 RETURNS TABLE(driver_name text, v_type text, speed smallint, user_driver_distance integer, eta integer)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE 
	query_time timestamp:=now()::timestamp;
	origin_count INT;
	destination_count INT;
	average_user_distance real;
	user_segment_array TEXT[];
	data_record record;
	user_total_segment_distance real;
	driver_name text;
	credit int;
	query_identifier uuid;
BEGIN
	if (public.check_is_admin() or public.check_is_driver() or public.update_daily_credit())=false then
		raise exception 'Limit Reached';
	end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)
	select
		FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS user_segment_array
	INTO
		average_user_distance,
		origin_count,
		destination_count,
		user_segment_array
	FROM distance_from_origin_table;

	select distance 
	from public.distancetable 
	where (start_node = any(user_segment_array) and end_node = any(user_segment_array)) into user_total_segment_distance;

	select code 
	from public.nodescode 
	where nodes=dest into dest;

	select daily_credits,identifier 
	into credit,query_identifier
	from public.profile
	where((SELECT auth.uid() AS uid)=profile.id);

	insert into public.user_search("datetime","lat","long","credit","destination","identifier")
	values(
		query_time,lat,long,credit+1,dest,query_identifier
	);
	return query	
	with initial_table as(
		SELECT p.driver,p.speed,is_reversed_route,p.segment as current_segment,
			public.distancetable.distance as total_segment_distance,-- driver
			query_time-p.time as time_active,p.v_type,
			floor
				(
				(1000*(p.speed) * (EXTRACT(EPOCH FROM (query_time-p.time)) / 3600))+
				p.segment_distance
			) as extrapolated_distance,--driver distance traveled with time queried and driver-time_updated
			array[r.origin]||r.route|| array[r.destination] as complete_driver_routes--routes of driver from origin to destination
			-- string_to_array(segment,',') as current_segment--current segment of driver
		FROM public.pasada p
		inner join  public.route_table r on p.driver_route= r.id
		inner join public.distancetable on p.segment = array[public.distancetable.start_node]||array[public.distancetable.end_node]
	),
	segments_table as(
		select *,
			array_position(complete_driver_routes,current_segment[1]) as pos_current_segment_one,--leg segment of driver starting
			array_position(complete_driver_routes,current_segment[2]) as pos_current_segment_two,--leg segment of driver ending
			array_position(complete_driver_routes,user_segment_array[1]) as pos_user_segment_one,--leg segment of user starting
			array_position(complete_driver_routes,user_segment_array[2]) as pos_user_segment_two,--leg segment of user ending
			array_position(complete_driver_routes,dest) as pos_user_destination--position of user destination
		from initial_table
		where (
			dest =any(complete_driver_routes)
			and time_active<interval '30 minutes'
			and time_active>interval '-30 minutes'
			and user_segment_array<@complete_driver_routes --user segment in complete driver route
		)
	),
	filtered_table as(
		select*
		from
			segments_table
		where (complete_driver_routes[1]=any(user_segment_array) and complete_driver_routes[array_length(complete_driver_routes, 1)]=any(user_segment_array) --same segment for both user and driver 
			and case
				when is_reversed_route=true 
					and dest= complete_driver_routes[1] and average_user_distance<segments_table.extrapolated_distance
				then 1
				when is_reversed_route=false 
				and dest = complete_driver_routes[array_length(complete_driver_routes, 1)] and average_user_distance>segments_table.extrapolated_distance
				then 1
				else 0
			end= 1
			) or
			(
				-- (
				-- dest = any(complete_driver_routes) --user destination in complete driver route
				-- and current_segment is not null
			case
				when is_reversed_route=false  --driver to lagawe, user to lagawe
					and dest= any(complete_driver_routes[greatest(pos_user_segment_two,pos_current_segment_two):])
					and case
						when pos_user_destination=pos_current_segment_two 
							and average_user_distance<segments_table.extrapolated_distance
						then 0
						else 1
					end =1
				then 1
				when is_reversed_route=true --driver to banaue user to banaue
					and dest= any(complete_driver_routes[:least(pos_user_segment_one,pos_current_segment_one)])
					and pos_current_segment_one-pos_user_segment_two>1
					and case
						when pos_user_destination=pos_current_segment_one 
							and average_user_distance>segments_table.extrapolated_distance
						then 0
						else 1
					end=1
				then 1
				else 0
			end =1
		)
	),
	-- calculate the distance and eta, segment considered
	user_driver_distance_table as(
		select driver,filtered_table.speed,filtered_table.extrapolated_distance, average_user_distance,v_type,
			case
				when pos_user_segment_one=pos_current_segment_one 
				then floor(abs(average_user_distance-filtered_table.extrapolated_distance)) --same segment
				when pos_user_segment_one-pos_current_segment_one=1
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance)) --adjacent segment
				when pos_user_segment_one-pos_current_segment_one>1 
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance))+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				when pos_current_segment_one-pos_user_segment_one=1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance) --adjacent segment
				when pos_current_segment_one-pos_user_segment_one>1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance)+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				-- else 0
			end as user_driver_distance
		from filtered_table
	),
	eta_calculations as(
		select *,
			floor(((user_driver_distance_table.user_driver_distance/1000)/user_driver_distance_table.speed)*60)::integer as eta
		from user_driver_distance_table
		ORDER BY eta
	),
  user_tables as(
    select COALESCE(p.username, 'Mr.Driver') as drv, 
    	v.type as vhc, 
		e.speed as spd, 
		e.user_driver_distance as dst, 
		e.eta,
		p.id as drv_id
    from eta_calculations e
    inner join public.profile p on e.driver=p.id
		inner join public.v_types v on e.v_type = v.id
  ),
	res_table as (
	SELECT drv,vhc,spd,dst::integer,user_tables.eta, public.upd_ctr(drv_id)
	FROM user_tables
  )
  select res_table.drv,res_table.vhc,res_table.spd,res_table.dst,res_table.eta
  from res_table;
END;$function$
;

CREATE OR REPLACE FUNCTION public.setlog(lats real, longs real, late real, longe real, stime timestamp without time zone, etime timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO ''
AS $function$DECLARE 
	uidd text;
	route int;
	max_int int;
BEGIN
	select p.driver,p.driver_route into uidd, route
	from public.pasada p
	where (( SELECT auth.uid() AS uid) = p.driver);
	select max(id) into max_int from public.driverlogs;
	
	insert into public.driverlogs("id","latStart","longStart","latEnd","longEnd","route","starttime","endtime","driver_id")
	values(max_int+1,latS,longS,latE,longE,route,Stime,Etime,uidd::uuid);
	
	update public.driver_updates
	set drv = null,log_number=max_int+1
	where ( SELECT auth.uid() AS uid) = drv;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_daily_credit()
 RETURNS boolean
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$declare
is_credible boolean;
counts integer;
daily_id uuid;
begin
with updated as(
    UPDATE public.profile
    SET 
        last_query = CASE 
            WHEN  subscription>=current_date THEN current_date
            -- WHEN last_query = current_date AND daily_credits > 0 THEN last_query
            -- ELSE last_query
        END,
        daily_credits = CASE 
            WHEN  (subscription>=current_date and (current_date>last_query or last_query is null)) THEN 9 
            WHEN (last_query = current_date AND daily_credits > 0) THEN daily_credits - 1 
            ELSE daily_credits
        end
    where (
    ((daily_credits>0 and last_query=current_date) or 
    (last_query<current_date and subscription>=current_date)
    or (subscription>current_date and last_query is null)
    ) and
    (( SELECT auth.uid() AS uid) = id))

    returning *
)

SELECT COUNT(*) INTO counts FROM updated;
if counts>0 then
  is_credible:=true;
else
  is_credible:=false;
end if;
if counts=9 then
  update public.profile
  set identifier =gen_random_uuid()
  where ( SELECT auth.uid() AS uid) = profile.id;
end if;
return is_credible;
end;$function$
;

grant delete on table "public"."driver_updates" to "service_role";

grant insert on table "public"."driver_updates" to "service_role";

grant references on table "public"."driver_updates" to "service_role";

grant select on table "public"."driver_updates" to "service_role";

grant trigger on table "public"."driver_updates" to "service_role";

grant truncate on table "public"."driver_updates" to "service_role";

grant update on table "public"."driver_updates" to "service_role";

grant delete on table "public"."user_search" to "service_role";

grant insert on table "public"."user_search" to "service_role";

grant references on table "public"."user_search" to "service_role";

grant select on table "public"."user_search" to "service_role";

grant trigger on table "public"."user_search" to "service_role";

grant truncate on table "public"."user_search" to "service_role";

grant update on table "public"."user_search" to "service_role";

create policy "anon_auth_restrict"
on "public"."driver_updates"
as restrictive
for all
to anon, authenticated
using (false)
with check (false);


create policy "anon_restrict"
on "public"."profile"
as restrictive
for all
to anon
using (false)
with check (false);


create policy "cannot insert"
on "public"."profile"
as permissive
for insert
to authenticated
with check (false);


create policy "cannot_delete"
on "public"."profile"
as permissive
for delete
to authenticated
using (false);


create policy "cannot_update_own_data"
on "public"."profile"
as permissive
for update
to authenticated
using (false)
with check (false);


create policy "anon_auth_restrict"
on "public"."roles"
as restrictive
for all
to anon, authenticated
using (false)
with check (false);


create policy "anon_auth_restrict"
on "public"."user_search"
as restrictive
for all
to anon, authenticated
using (false)
with check (false);

REVOKE ALL on public.driver_updates FROM public;
Revoke all on public.driver_updates from authenticated,anon;
grant all on public.driver_updates to postgres;
REVOKE ALL on public.user_search FROM public;
Revoke all on public.user_search from authenticated,anon;
grant all on public.user_search to postgres;


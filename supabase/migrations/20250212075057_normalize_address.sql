create extension if not exists "pgtap" with schema "extensions";


create table "public"."barangays" (
    "id" integer generated by default as identity not null,
    "barangay" text not null,
    "municipality" smallint,
    "province" smallint
);


alter table "public"."barangays" enable row level security;

create table "public"."distancetable" (
    "id" bigint not null,
    "start_node" text,
    "end_node" text,
    "distance" double precision
);


alter table "public"."distancetable" enable row level security;

create table "public"."driverlogs" (
    "id" bigint generated by default as identity not null,
    "latEnd" double precision,
    "longEnd" double precision,
    "route" smallint,
    "starttime" timestamp without time zone,
    "endtime" timestamp without time zone,
    "driver_id" uuid default auth.uid(),
    "latStart" double precision,
    "longStart" double precision not null
);


alter table "public"."driverlogs" enable row level security;

create table "public"."kmsegments" (
    "table_id" bigint not null,
    "distance" double precision,
    "latitude" double precision,
    "longitude" double precision,
    "origin" text,
    "destination" text
);


alter table "public"."kmsegments" enable row level security;

create table "public"."municipalities" (
    "id" smallint generated by default as identity not null,
    "municipality" text not null
);


alter table "public"."municipalities" enable row level security;

create table "public"."nodescode" (
    "nodes" text,
    "code" text not null
);


alter table "public"."nodescode" enable row level security;

create table "public"."organization" (
    "id" integer generated by default as identity not null,
    "orgName" text not null,
    "officialName" text
);


alter table "public"."organization" enable row level security;

create table "public"."pasada" (
    "driver" uuid not null,
    "speed" smallint,
    "time" timestamp with time zone,
    "segment_distance" numeric,
    "is_reversed_route" boolean,
    "driver_route" smallint,
    "segment" text[],
    "latitude" double precision,
    "longitude" double precision,
    "organization" integer,
    "counter" bigint
);


alter table "public"."pasada" enable row level security;

create table "public"."profile" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "firstname" text,
    "lastname" text,
    "province" smallint not null,
    "municipality" smallint not null,
    "barangay" integer,
    "bday" text,
    "username" text,
    "role" bigint,
    "subscription" date,
    "v_type" smallint default '5'::smallint,
    "daily_credits" smallint,
    "last_query" date,
    "phone" text,
    "has_paid" boolean not null default false
);


alter table "public"."profile" enable row level security;

create table "public"."provinces" (
    "id" smallint generated by default as identity not null,
    "province" text not null
);


alter table "public"."provinces" enable row level security;

create table "public"."roles" (
    "id" bigint generated by default as identity not null,
    "roles" text not null
);


alter table "public"."roles" enable row level security;

create table "public"."route_table" (
    "id" bigint not null,
    "origin" text,
    "destination" text,
    "route" text[]
);


alter table "public"."route_table" enable row level security;

create table "public"."v_types" (
    "id" smallint generated by default as identity not null,
    "type" text not null
);


alter table "public"."v_types" enable row level security;

CREATE UNIQUE INDEX "Organization_pkey" ON public.organization USING btree (id);

CREATE UNIQUE INDEX barangays_pkey ON public.barangays USING btree (id);

CREATE UNIQUE INDEX distancetable_pkey ON public.distancetable USING btree (id);

CREATE UNIQUE INDEX driverlogs_pkey ON public.driverlogs USING btree (id);

CREATE UNIQUE INDEX kmsegments_pkey ON public.kmsegments USING btree (table_id);

CREATE UNIQUE INDEX municipalities_pkey ON public.municipalities USING btree (id);

CREATE UNIQUE INDEX nodescode_pkey ON public.nodescode USING btree (code);

CREATE UNIQUE INDEX "organization_Organization_key" ON public.organization USING btree ("orgName");

CREATE UNIQUE INDEX "organization_officialName_key" ON public.organization USING btree ("officialName");

CREATE UNIQUE INDEX profile_pkey ON public.profile USING btree (id);

CREATE UNIQUE INDEX provinces_id_key ON public.provinces USING btree (id);

CREATE UNIQUE INDEX provinces_pkey ON public.provinces USING btree (id);

CREATE UNIQUE INDEX road_drivers_pkey ON public.pasada USING btree (driver);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX route_table_pkey ON public.route_table USING btree (id);

CREATE UNIQUE INDEX v_types_pkey ON public.v_types USING btree (id);

alter table "public"."barangays" add constraint "barangays_pkey" PRIMARY KEY using index "barangays_pkey";

alter table "public"."distancetable" add constraint "distancetable_pkey" PRIMARY KEY using index "distancetable_pkey";

alter table "public"."driverlogs" add constraint "driverlogs_pkey" PRIMARY KEY using index "driverlogs_pkey";

alter table "public"."kmsegments" add constraint "kmsegments_pkey" PRIMARY KEY using index "kmsegments_pkey";

alter table "public"."municipalities" add constraint "municipalities_pkey" PRIMARY KEY using index "municipalities_pkey";

alter table "public"."nodescode" add constraint "nodescode_pkey" PRIMARY KEY using index "nodescode_pkey";

alter table "public"."organization" add constraint "Organization_pkey" PRIMARY KEY using index "Organization_pkey";

alter table "public"."pasada" add constraint "road_drivers_pkey" PRIMARY KEY using index "road_drivers_pkey";

alter table "public"."profile" add constraint "profile_pkey" PRIMARY KEY using index "profile_pkey";

alter table "public"."provinces" add constraint "provinces_pkey" PRIMARY KEY using index "provinces_pkey";

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."route_table" add constraint "route_table_pkey" PRIMARY KEY using index "route_table_pkey";

alter table "public"."v_types" add constraint "v_types_pkey" PRIMARY KEY using index "v_types_pkey";

alter table "public"."barangays" add constraint "barangays_municipality_fkey" FOREIGN KEY (municipality) REFERENCES municipalities(id) not valid;

alter table "public"."barangays" validate constraint "barangays_municipality_fkey";

alter table "public"."barangays" add constraint "barangays_province_fkey" FOREIGN KEY (province) REFERENCES provinces(id) not valid;

alter table "public"."barangays" validate constraint "barangays_province_fkey";

alter table "public"."distancetable" add constraint "distancetable_end_node_fkey" FOREIGN KEY (end_node) REFERENCES nodescode(code) not valid;

alter table "public"."distancetable" validate constraint "distancetable_end_node_fkey";

alter table "public"."distancetable" add constraint "distancetable_start_node_fkey" FOREIGN KEY (start_node) REFERENCES nodescode(code) not valid;

alter table "public"."distancetable" validate constraint "distancetable_start_node_fkey";

alter table "public"."driverlogs" add constraint "driverlogs_route_fkey" FOREIGN KEY (route) REFERENCES route_table(id) not valid;

alter table "public"."driverlogs" validate constraint "driverlogs_route_fkey";

alter table "public"."kmsegments" add constraint "kmsegments_destination_fkey" FOREIGN KEY (destination) REFERENCES nodescode(code) ON UPDATE CASCADE not valid;

alter table "public"."kmsegments" validate constraint "kmsegments_destination_fkey";

alter table "public"."kmsegments" add constraint "kmsegments_origin_fkey" FOREIGN KEY (origin) REFERENCES nodescode(code) ON UPDATE CASCADE not valid;

alter table "public"."kmsegments" validate constraint "kmsegments_origin_fkey";

alter table "public"."organization" add constraint "organization_Organization_key" UNIQUE using index "organization_Organization_key";

alter table "public"."organization" add constraint "organization_officialName_key" UNIQUE using index "organization_officialName_key";

alter table "public"."pasada" add constraint "pasada_driver_fkey" FOREIGN KEY (driver) REFERENCES auth.users(id) ON UPDATE CASCADE not valid;

alter table "public"."pasada" validate constraint "pasada_driver_fkey";

alter table "public"."pasada" add constraint "pasada_driver_route_fkey" FOREIGN KEY (driver_route) REFERENCES route_table(id) not valid;

alter table "public"."pasada" validate constraint "pasada_driver_route_fkey";

alter table "public"."pasada" add constraint "pasada_organization_fkey" FOREIGN KEY (organization) REFERENCES organization(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."pasada" validate constraint "pasada_organization_fkey";

alter table "public"."profile" add constraint "profile_barangay_fkey" FOREIGN KEY (barangay) REFERENCES barangays(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."profile" validate constraint "profile_barangay_fkey";

alter table "public"."profile" add constraint "profile_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_id_fkey";

alter table "public"."profile" add constraint "profile_phone_check" CHECK ((length(phone) = 11)) not valid;

alter table "public"."profile" validate constraint "profile_phone_check";

alter table "public"."profile" add constraint "profile_role_fkey" FOREIGN KEY (role) REFERENCES roles(id) ON UPDATE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_role_fkey";

alter table "public"."profile" add constraint "profile_username_check" CHECK ((length(username) <= 50)) not valid;

alter table "public"."profile" validate constraint "profile_username_check";

alter table "public"."profile" add constraint "profile_v_type_fkey" FOREIGN KEY (v_type) REFERENCES v_types(id) ON UPDATE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_v_type_fkey";

alter table "public"."provinces" add constraint "provinces_id_key" UNIQUE using index "provinces_id_key";

alter table "public"."route_table" add constraint "route_table_destination_fkey" FOREIGN KEY (destination) REFERENCES nodescode(code) ON UPDATE CASCADE not valid;

alter table "public"."route_table" validate constraint "route_table_destination_fkey";

alter table "public"."route_table" add constraint "route_table_origin_fkey" FOREIGN KEY (origin) REFERENCES nodescode(code) ON UPDATE CASCADE not valid;

alter table "public"."route_table" validate constraint "route_table_origin_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_is_admin()
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE STRICT
 SET search_path TO ''
AS $function$
declare
conditions_met boolean:=false;
begin
if current_user ='postgres' then
		conditions_met := true;
end if;
if conditions_met = false then
	select exists(
	  select p.id,r.roles,p.username
	  from public.profile p
	  inner join public.roles r on p.role=r.id 
	  where (r.roles='admin'and (( SELECT auth.uid() AS uid) = p.id))
	) into conditions_met;
end if;
return conditions_met;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.check_is_driver()
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE
 SET search_path TO ''
AS $function$declare
conditions_met boolean:=false;
begin
select exists(
  select p.id,r.roles,p.username
  from public.profile p
  inner join public.roles r on p.role=r.id 
  where (r.roles='driver'and (( SELECT auth.uid() AS uid) = p.id))
) into conditions_met;
return conditions_met;
end;$function$
;

CREATE OR REPLACE FUNCTION public.combine_segment_array(input_array text[], driver_index integer, passenger_index integer)
 RETURNS text[]
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$DECLARE

    segment_array TEXT[] := '{}';
    segment TEXT;
    i INT;
	-- start_segment text;
	-- end_segment text;
BEGIN
    -- Transform input_array to segment_array
    FOR i IN driver_index..passenger_index-1
		LOOP
			-- start_segment:=public.get_text_code(input_array[i]);
			-- end_segment:=public.get_text_code(input_array[i+1]);
	        segment :=  input_array[i]|| '-' || input_array[i+1];
	        segment_array := array_append(segment_array, segment);
    	END LOOP;

	return segment_array;
END;$function$
;

CREATE OR REPLACE FUNCTION public.distance_driver_passenger(segment_array text[])
 RETURNS real
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
DECLARE
	partial_sum real;
BEGIN
    -- Transform input_array to segment_array

	with filtered_distance as(
		select distance,
			start_node||'-'||end_node as start_end
		from distancetable
	)
	select ceil(sum(distance)) into partial_sum
	from filtered_distance
	where start_end = any(segment_array);
	return partial_sum;	
END;
$function$
;

CREATE OR REPLACE FUNCTION public.distance_from_origin(lat real, long real)
 RETURNS TABLE(origin text, destination text, total_distance real, new_segment_text text[])
 LANGUAGE plpgsql
 STABLE STRICT ROWS 2
 SET search_path TO ''
AS $function$
BEGIN
  return query
	WITH CloseCheckpoints AS (
        select latitude,
		longitude,
		distance,
		public.kmsegments.origin,
		public.kmsegments.destination,
	    6371 * acos(
	        cos(radians(lat)) * cos(radians(latitude)) * 
	        cos(radians(longitude) - radians(long)) +
	        sin(radians(lat)) * sin(radians(latitude))
	    )*1000 as additional_distance,
		row_number() over (order by table_id) as rowNum
		from public.kmsegments
        WHERE latitude between lat-0.000449 and lat+0.000449
        and longitude between long-0.000477 and long+0.000477
		limit 2
    )
	
  Select CloseCheckpoints.origin,CloseCheckpoints.destination,
	case
		when rowNum = 1 then floor(distance+additional_distance)::real
	 	when rowNum = 2 then floor(distance-additional_distance)::real
		else distance::real
	end as total_distance,
	array[CloseCheckpoints.origin]||array[CloseCheckpoints.destination] as new_segment_text 
    From CloseCheckpoints;
END
$function$
;

CREATE OR REPLACE FUNCTION public.drv_min(lat real, long real, upd_tme timestamp without time zone, spd integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE 
	origin_count INT; 
	destination_count INT;
	average_distance double precision;
	segment_var text[];
BEGIN
if public.check_is_driver()=false then
	return;
end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)

	select
	 	FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS segment_var
	into
		average_distance, 
		origin_count, 
		destination_count,
		segment_var
	FROM distance_from_origin_table;
	
	IF origin_count = 1 AND destination_count = 1 THEN 
		UPDATE public.pasada 
		SET segment = segment_var
		WHERE driver =( SELECT auth.uid() AS uid);
	end if;
	UPDATE public.pasada 
	SET segment_distance =  average_distance,time=upd_tme,
	latitude= lat,longitude=long,speed=spd
	WHERE driver = ( SELECT auth.uid() AS uid);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.drv_set(ogn text, dest text, lat real, long real, tme timestamp without time zone, spd integer)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
origin_code text;
destination_code text;
is_route_reversed boolean;
route_id int;

begin
if public.check_is_driver()=false then
	return;
end if;
origin_code:=public.get_text_code(ogn);
destination_code:=public.get_text_code(dest);

SELECT route_table.id into route_id
FROM public.route_table
WHERE (
	route_table.destination = any(array[origin_code,destination_code]) 
	and route_table.origin =any(array[origin_code,destination_code])
	and origin_code!=destination_code
);

if route_id is not null
	then
		SELECT EXISTS (
			SELECT route_table.id FROM public.route_table
				WHERE (route_table.origin = destination_code and route_table.id =route_id)
		) into is_route_reversed;
		
		insert into public.pasada (driver,is_reversed_route,driver_route)
		values (auth.uid()::uuid,is_route_reversed,route_id)
		on conflict(driver)
		do update set
			is_reversed_route = excluded.is_reversed_route,
			driver_route = route_id;
		perform public.drv_min(lat::real ,long::real,tme::timestamp,spd::int);
	else
		raise notice 'null';
	end if;
end
$function$
;

CREATE OR REPLACE FUNCTION public.get_text_code(node_var text)
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$DECLARE 
	code_text text; 
BEGIN 
	select code into code_text
	FROM public.nodescode 
	WHERE nodes = node_var
	Limit 1;
	RETURN code_text;
END;$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
Begin
Insert into public.profile(id,firstname,lastname,province,municipality,barangay,bday,username)
Values (
  new.id, new.raw_user_meta_data ->> 'first_name', new.raw_user_meta_data ->> 'last_name',
  new.raw_user_meta_data ->> 'province', new.raw_user_meta_data ->> 'municipality',
  new.raw_user_meta_data ->> 'barangay', new.raw_user_meta_data ->> 'bday',
  new.raw_user_meta_data ->> 'username'
);
return new;
End;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user2()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
prov smallint;
mun  smallint;
brgy  int;
Begin
Select id into prov
from provinces
where province=new.raw_user_meta_data ->> 'province';
Select id into mun
from municipalities
where municipality=new.raw_user_meta_data ->> 'municipality';

Select id into brgy
from barangays
where barangay = new.raw_user_meta_data ->> 'barangay' and barangays.municipality=mun and barangays.province=prov;
Insert into public.profile(id,firstname,lastname,province,municipality,barangay,bday,username)
Values (
  new.id, new.raw_user_meta_data ->> 'first_name', new.raw_user_meta_data ->> 'last_name',
  prov, mun,
  brgy, new.raw_user_meta_data ->> 'bday',
  new.raw_user_meta_data ->> 'username'
);
RETURN new;  
END;$function$
;

CREATE OR REPLACE FUNCTION public.inbetween_segmental_distance(input_array text[], driver_index integer, passenger_index integer)
 RETURNS real
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$DECLARE
    segment_array TEXT[] := '{}';
    partial_sum real;
BEGIN
    -- Transform input_array to segment_array
	segment_array :=public.combine_segment_array(
		input_array,least(driver_index,passenger_index),greatest(driver_index,passenger_index)
		);
	raise notice 'distances to add:%',segment_array;
	partial_sum:=public.distance_driver_passenger(segment_array);
	raise notice '%',partial_sum;
	return partial_sum;
END;$function$
;

CREATE OR REPLACE FUNCTION public.insert_to_driver_table()
 RETURNS trigger
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare
role_text text;
BEGIN
  select roles into role_text 
  from public.roles 
  where id=NEW.role;

  if role_text = 'driver' then
    INSERT INTO public.pasada (driver)
    VALUES (NEW.id)
    ON CONFLICT (driver) DO nothing;
  end if;
  return NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.q_drivers(lat real, long real, dest text)
 RETURNS TABLE(driver_id text, type text, speed smallint, user_driver_distance double precision, eta integer)
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER ROWS 10
 SET search_path TO ''
AS $function$
DECLARE 
	query_time timestamp:=now()::timestamp;
	origin_count INT;
	destination_count INT;
	average_user_distance real;
	user_segment_array TEXT[];
	data_record record;
	user_total_segment_distance real;

BEGIN
	if (public.check_is_admin() or public.check_is_driver() or public.update_daily_credit())=false then
		return;
	end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)
	select
		FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS user_segment_array
	INTO
		average_user_distance,
		origin_count,
		destination_count,
		user_segment_array
	FROM distance_from_origin_table;

	select distance 
	from public.distancetable 
	where (start_node = any(user_segment_array) and end_node = any(user_segment_array)) into user_total_segment_distance;

	select code 
	from public.nodescode 
	where nodes=dest into dest;

	return query	
	with initial_table as(
		SELECT p.driver,p.speed,is_reversed_route,p.segment as current_segment,
			public.distancetable.distance as total_segment_distance,-- driver
			query_time-p.time as time_active,
			floor
				(
				(1000*(p.speed) * (EXTRACT(EPOCH FROM (query_time-p.time)) / 3600))+
				p.segment_distance
			) as extrapolated_distance,--driver distance traveled with time queried and driver-time_updated
			array[r.origin]||r.route|| array[r.destination] as complete_driver_routes--routes of driver from origin to destination
			-- string_to_array(segment,',') as current_segment--current segment of driver
		FROM public.pasada p
		inner join  public.route_table r on p.driver_route= r.id
		inner join public.distancetable on p.segment = array[public.distancetable.start_node]||array[public.distancetable.end_node]
	),
	segments_table as(
		select *,
			array_position(complete_driver_routes,current_segment[1]) as pos_current_segment_one,--leg segment of driver starting
			array_position(complete_driver_routes,current_segment[2]) as pos_current_segment_two,--leg segment of driver ending
			array_position(complete_driver_routes,user_segment_array[1]) as pos_user_segment_one,--leg segment of user starting
			array_position(complete_driver_routes,user_segment_array[2]) as pos_user_segment_two,--leg segment of user ending
			array_position(complete_driver_routes,dest) as pos_user_destination--position of user destination
		from initial_table
		where (
			dest =any(complete_driver_routes)
			and time_active<interval '30 minutes'
			and time_active>interval '-30 minutes'
			and user_segment_array<@complete_driver_routes --user segment in complete driver route
		)
	),
	filtered_table as(
		select*
		from
			segments_table
		where (complete_driver_routes[1]=any(user_segment_array) and complete_driver_routes[array_length(complete_driver_routes, 1)]=any(user_segment_array) --same segment for both user and driver 
			and case
				when is_reversed_route=true 
					and dest= complete_driver_routes[1] and average_user_distance<segments_table.extrapolated_distance
				then 1
				when is_reversed_route=false 
				and dest = complete_driver_routes[array_length(complete_driver_routes, 1)] and average_user_distance>segments_table.extrapolated_distance
				then 1
				else 0
			end= 1
			) or
			(
				-- (
				-- dest = any(complete_driver_routes) --user destination in complete driver route
				-- and current_segment is not null
			case
				when is_reversed_route=false  --driver to lagawe, user to lagawe
					and dest= any(complete_driver_routes[greatest(pos_user_segment_two,pos_current_segment_two):])
					and case
						when pos_user_destination=pos_current_segment_two 
							and average_user_distance<segments_table.extrapolated_distance
						then 0
						else 1
					end =1
				then 1
				when is_reversed_route=true --driver to banaue user to banaue
					and dest= any(complete_driver_routes[:least(pos_user_segment_one,pos_current_segment_one)])
					and pos_current_segment_one-pos_user_segment_two>1
					and case
						when pos_user_destination=pos_current_segment_one 
							and average_user_distance>segments_table.extrapolated_distance
						then 0
						else 1
					end=1
				then 1
				else 0
			end =1
		)
	),
	-- calculate the distance and eta, segment considered
	user_driver_distance_table as(
		select driver,filtered_table.speed,filtered_table.extrapolated_distance, average_user_distance,
			case
				when pos_user_segment_one=pos_current_segment_one 
				then floor(abs(average_user_distance-filtered_table.extrapolated_distance)) --same segment
				when pos_user_segment_one-pos_current_segment_one=1
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance)) --adjacent segment
				when pos_user_segment_one-pos_current_segment_one>1 
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance))+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				when pos_current_segment_one-pos_user_segment_one=1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance) --adjacent segment
				when pos_current_segment_one-pos_user_segment_one>1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance)+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				-- else 0
			end as user_driver_distance
		from filtered_table
	),
	eta_calculations as(
		select *,
			floor(((user_driver_distance_table.user_driver_distance/1000)/user_driver_distance_table.speed)*60)::integer as eta
		from user_driver_distance_table
		ORDER BY eta
	),
  user_tables as(
    select COALESCE(p.username, 'Mr.Driver') AS driver_name, 
    v.type, 
		e.speed, 
		e.user_driver_distance, 
		e.eta
    from eta_calculations e
    inner join public.profile p on e.driver=p.id
		inner join public.v_types v on p.v_type = v.id
  )
	SELECT *
	FROM user_tables;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.q_drivers2(lat real, long real, dest text)
 RETURNS TABLE(driver_name text, v_type text, speed smallint, user_driver_distance integer, eta integer)
 LANGUAGE plpgsql
 SECURITY DEFINER ROWS 5
 SET search_path TO ''
AS $function$
DECLARE 
	query_time timestamp:=now()::timestamp;
	origin_count INT;
	destination_count INT;
	average_user_distance real;
	user_segment_array TEXT[];
	data_record record;
	user_total_segment_distance real;
	driver_name text;
BEGIN
	if (public.check_is_admin() or public.check_is_driver() or public.update_daily_credit())=false then
		raise exception 'Limit Reached';
	end if;
	WITH distance_from_origin_table as(
		SELECT *
		FROM public.distance_from_origin(lat,long)
	)
	select
		FLOOR( AVG(total_distance)) as avg_distance,
		COUNT(DISTINCT origin) as origin_count,
		COUNT(DISTINCT destination) as destination_count,
		MODE() WITHIN GROUP (ORDER BY new_segment_text) AS user_segment_array
	INTO
		average_user_distance,
		origin_count,
		destination_count,
		user_segment_array
	FROM distance_from_origin_table;

	select distance 
	from public.distancetable 
	where (start_node = any(user_segment_array) and end_node = any(user_segment_array)) into user_total_segment_distance;

	select code 
	from public.nodescode 
	where nodes=dest into dest;

	return query	
	with initial_table as(
		SELECT p.driver,p.speed,is_reversed_route,p.segment as current_segment,
			public.distancetable.distance as total_segment_distance,-- driver
			query_time-p.time as time_active,
			floor
				(
				(1000*(p.speed) * (EXTRACT(EPOCH FROM (query_time-p.time)) / 3600))+
				p.segment_distance
			) as extrapolated_distance,--driver distance traveled with time queried and driver-time_updated
			array[r.origin]||r.route|| array[r.destination] as complete_driver_routes--routes of driver from origin to destination
			-- string_to_array(segment,',') as current_segment--current segment of driver
		FROM public.pasada p
		inner join  public.route_table r on p.driver_route= r.id
		inner join public.distancetable on p.segment = array[public.distancetable.start_node]||array[public.distancetable.end_node]
	),
	segments_table as(
		select *,
			array_position(complete_driver_routes,current_segment[1]) as pos_current_segment_one,--leg segment of driver starting
			array_position(complete_driver_routes,current_segment[2]) as pos_current_segment_two,--leg segment of driver ending
			array_position(complete_driver_routes,user_segment_array[1]) as pos_user_segment_one,--leg segment of user starting
			array_position(complete_driver_routes,user_segment_array[2]) as pos_user_segment_two,--leg segment of user ending
			array_position(complete_driver_routes,dest) as pos_user_destination--position of user destination
		from initial_table
		where (
			dest =any(complete_driver_routes)
			and time_active<interval '30 minutes'
			and time_active>interval '-30 minutes'
			and user_segment_array<@complete_driver_routes --user segment in complete driver route
		)
	),
	filtered_table as(
		select*
		from
			segments_table
		where (complete_driver_routes[1]=any(user_segment_array) and complete_driver_routes[array_length(complete_driver_routes, 1)]=any(user_segment_array) --same segment for both user and driver 
			and case
				when is_reversed_route=true 
					and dest= complete_driver_routes[1] and average_user_distance<segments_table.extrapolated_distance
				then 1
				when is_reversed_route=false 
				and dest = complete_driver_routes[array_length(complete_driver_routes, 1)] and average_user_distance>segments_table.extrapolated_distance
				then 1
				else 0
			end= 1
			) or
			(
				-- (
				-- dest = any(complete_driver_routes) --user destination in complete driver route
				-- and current_segment is not null
			case
				when is_reversed_route=false  --driver to lagawe, user to lagawe
					and dest= any(complete_driver_routes[greatest(pos_user_segment_two,pos_current_segment_two):])
					and case
						when pos_user_destination=pos_current_segment_two 
							and average_user_distance<segments_table.extrapolated_distance
						then 0
						else 1
					end =1
				then 1
				when is_reversed_route=true --driver to banaue user to banaue
					and dest= any(complete_driver_routes[:least(pos_user_segment_one,pos_current_segment_one)])
					and pos_current_segment_one-pos_user_segment_two>1
					and case
						when pos_user_destination=pos_current_segment_one 
							and average_user_distance>segments_table.extrapolated_distance
						then 0
						else 1
					end=1
				then 1
				else 0
			end =1
		)
	),
	-- calculate the distance and eta, segment considered
	user_driver_distance_table as(
		select driver,filtered_table.speed,filtered_table.extrapolated_distance, average_user_distance,
			case
				when pos_user_segment_one=pos_current_segment_one 
				then floor(abs(average_user_distance-filtered_table.extrapolated_distance)) --same segment
				when pos_user_segment_one-pos_current_segment_one=1
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance)) --adjacent segment
				when pos_user_segment_one-pos_current_segment_one>1 
					and is_reversed_route= false
				then floor (average_user_distance+(total_segment_distance-filtered_table.extrapolated_distance))+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				when pos_current_segment_one-pos_user_segment_one=1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance) --adjacent segment
				when pos_current_segment_one-pos_user_segment_one>1 
					and is_reversed_route= true
				then floor ((user_total_segment_distance-average_user_distance)+filtered_table.extrapolated_distance)+ --inbetween segment
					public.inbetween_segmental_distance(
						complete_driver_routes,pos_user_segment_one,
						pos_current_segment_one)
				-- else 0
			end as user_driver_distance
		from filtered_table
	),
	eta_calculations as(
		select *,
			floor(((user_driver_distance_table.user_driver_distance/1000)/user_driver_distance_table.speed)*60)::integer as eta
		from user_driver_distance_table
		ORDER BY eta
	),
  user_tables as(
    select COALESCE(p.username, 'Mr.Driver') as drv, 
    	v.type as vhc, 
		e.speed as spd, 
		e.user_driver_distance as dst, 
		e.eta,
		p.id as drv_id
    from eta_calculations e
    inner join public.profile p on e.driver=p.id
		inner join public.v_types v on p.v_type = v.id
  ),
	res_table as (
	SELECT drv,vhc,spd,dst::integer,user_tables.eta, public.upd_ctr(drv_id)
	FROM user_tables
  )
  select res_table.drv,res_table.vhc,res_table.spd,res_table.dst,res_table.eta
  from res_table;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.setlog(lats real, longs real, late real, longe real, stime timestamp without time zone, etime timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
 STRICT SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE 
	uidd text;
	route int;
BEGIN
	select p.driver,p.driver_route into uidd, route
	from public.pasada p
	where (( SELECT auth.uid() AS uid) = p.driver);
	insert into public.driverlogs("driver_id","latStart","longStart","latEnd","longEnd","route","starttime","endtime")
	values(auth.uid(),latS,longS,latE,longE,route,Stime,Etime);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upd_ctr(uid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  is_paid boolean;
  is_set boolean:= false;
begin
  select has_paid into is_paid
  from public.profile
  where id=auth.uid();
  if is_paid=true then
  	update public.pasada
  	set counter = counter+1
  	where id = uid;
	is_set =true;
	end if;
  return is_set;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_daily_credit()
 RETURNS boolean
 LANGUAGE plpgsql
 STRICT
 SET search_path TO ''
AS $function$
declare
is_credible boolean;
counts integer;

begin
with updated as(
    UPDATE public.profile
    SET 
        last_query = CASE 
            WHEN  subscription>=current_date THEN current_date
            -- WHEN last_query = current_date AND daily_credits > 0 THEN last_query
            -- ELSE last_query
        END,
        daily_credits = CASE 
            WHEN  (subscription>=current_date and (current_date>last_query or last_query is null)) THEN 9 
            WHEN (last_query = current_date AND daily_credits > 0) THEN daily_credits - 1 
            ELSE daily_credits
        end
    where (
    ((daily_credits>0 and last_query=current_date) or 
    (last_query<current_date and subscription>=current_date)
    or (subscription>current_date and last_query is null)
    ) and
    (( SELECT auth.uid() AS uid) = id))

    returning *
)
SELECT COUNT(*) INTO counts FROM updated;
if counts>0 then
  is_credible:=true;
else
  is_credible:=false;
end if;
return is_credible;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_search_counter(uuids uuid[])
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  is_paid boolean;
begin
  select has_paid into is_paid
  from public.profile
  where id=auth.id();
  if is_paid=true then
	  update public.pasada
	  set counter = counter+1
	  where id = any(uuids);
	end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_sub(mail text, is_paid boolean, days integer)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$declare
  user_uuid uuid;
begin
  if not public.check_is_admin() then
    raise exception 'Unauthorized';
  end if;
  
  SELECT id INTO user_uuid
  FROM auth.users
  WHERE email = mail;
  if user_uuid is null then
    return false;
  end if;
  update public.profile
  set subscription = current_date+days,
    has_paid =is_paid,
    daily_credits =10
  where id =user_uuid;
  return true;
end;$function$
;

grant delete on table "public"."barangays" to "anon";

grant insert on table "public"."barangays" to "anon";

grant references on table "public"."barangays" to "anon";

grant select on table "public"."barangays" to "anon";

grant trigger on table "public"."barangays" to "anon";

grant truncate on table "public"."barangays" to "anon";

grant update on table "public"."barangays" to "anon";

grant delete on table "public"."barangays" to "authenticated";

grant insert on table "public"."barangays" to "authenticated";

grant references on table "public"."barangays" to "authenticated";

grant select on table "public"."barangays" to "authenticated";

grant trigger on table "public"."barangays" to "authenticated";

grant truncate on table "public"."barangays" to "authenticated";

grant update on table "public"."barangays" to "authenticated";

grant delete on table "public"."barangays" to "service_role";

grant insert on table "public"."barangays" to "service_role";

grant references on table "public"."barangays" to "service_role";

grant select on table "public"."barangays" to "service_role";

grant trigger on table "public"."barangays" to "service_role";

grant truncate on table "public"."barangays" to "service_role";

grant update on table "public"."barangays" to "service_role";

grant delete on table "public"."distancetable" to "anon";

grant insert on table "public"."distancetable" to "anon";

grant references on table "public"."distancetable" to "anon";

grant select on table "public"."distancetable" to "anon";

grant trigger on table "public"."distancetable" to "anon";

grant truncate on table "public"."distancetable" to "anon";

grant update on table "public"."distancetable" to "anon";

grant delete on table "public"."distancetable" to "authenticated";

grant insert on table "public"."distancetable" to "authenticated";

grant references on table "public"."distancetable" to "authenticated";

grant select on table "public"."distancetable" to "authenticated";

grant trigger on table "public"."distancetable" to "authenticated";

grant truncate on table "public"."distancetable" to "authenticated";

grant update on table "public"."distancetable" to "authenticated";

grant delete on table "public"."distancetable" to "service_role";

grant insert on table "public"."distancetable" to "service_role";

grant references on table "public"."distancetable" to "service_role";

grant select on table "public"."distancetable" to "service_role";

grant trigger on table "public"."distancetable" to "service_role";

grant truncate on table "public"."distancetable" to "service_role";

grant update on table "public"."distancetable" to "service_role";

grant delete on table "public"."driverlogs" to "anon";

grant insert on table "public"."driverlogs" to "anon";

grant references on table "public"."driverlogs" to "anon";

grant select on table "public"."driverlogs" to "anon";

grant trigger on table "public"."driverlogs" to "anon";

grant truncate on table "public"."driverlogs" to "anon";

grant update on table "public"."driverlogs" to "anon";

grant delete on table "public"."driverlogs" to "authenticated";

grant insert on table "public"."driverlogs" to "authenticated";

grant references on table "public"."driverlogs" to "authenticated";

grant select on table "public"."driverlogs" to "authenticated";

grant trigger on table "public"."driverlogs" to "authenticated";

grant truncate on table "public"."driverlogs" to "authenticated";

grant update on table "public"."driverlogs" to "authenticated";

grant delete on table "public"."driverlogs" to "service_role";

grant insert on table "public"."driverlogs" to "service_role";

grant references on table "public"."driverlogs" to "service_role";

grant select on table "public"."driverlogs" to "service_role";

grant trigger on table "public"."driverlogs" to "service_role";

grant truncate on table "public"."driverlogs" to "service_role";

grant update on table "public"."driverlogs" to "service_role";

grant delete on table "public"."kmsegments" to "anon";

grant insert on table "public"."kmsegments" to "anon";

grant references on table "public"."kmsegments" to "anon";

grant select on table "public"."kmsegments" to "anon";

grant trigger on table "public"."kmsegments" to "anon";

grant truncate on table "public"."kmsegments" to "anon";

grant update on table "public"."kmsegments" to "anon";

grant delete on table "public"."kmsegments" to "authenticated";

grant insert on table "public"."kmsegments" to "authenticated";

grant references on table "public"."kmsegments" to "authenticated";

grant select on table "public"."kmsegments" to "authenticated";

grant trigger on table "public"."kmsegments" to "authenticated";

grant truncate on table "public"."kmsegments" to "authenticated";

grant update on table "public"."kmsegments" to "authenticated";

grant delete on table "public"."kmsegments" to "service_role";

grant insert on table "public"."kmsegments" to "service_role";

grant references on table "public"."kmsegments" to "service_role";

grant select on table "public"."kmsegments" to "service_role";

grant trigger on table "public"."kmsegments" to "service_role";

grant truncate on table "public"."kmsegments" to "service_role";

grant update on table "public"."kmsegments" to "service_role";

grant delete on table "public"."municipalities" to "anon";

grant insert on table "public"."municipalities" to "anon";

grant references on table "public"."municipalities" to "anon";

grant select on table "public"."municipalities" to "anon";

grant trigger on table "public"."municipalities" to "anon";

grant truncate on table "public"."municipalities" to "anon";

grant update on table "public"."municipalities" to "anon";

grant delete on table "public"."municipalities" to "authenticated";

grant insert on table "public"."municipalities" to "authenticated";

grant references on table "public"."municipalities" to "authenticated";

grant select on table "public"."municipalities" to "authenticated";

grant trigger on table "public"."municipalities" to "authenticated";

grant truncate on table "public"."municipalities" to "authenticated";

grant update on table "public"."municipalities" to "authenticated";

grant delete on table "public"."municipalities" to "service_role";

grant insert on table "public"."municipalities" to "service_role";

grant references on table "public"."municipalities" to "service_role";

grant select on table "public"."municipalities" to "service_role";

grant trigger on table "public"."municipalities" to "service_role";

grant truncate on table "public"."municipalities" to "service_role";

grant update on table "public"."municipalities" to "service_role";

grant delete on table "public"."nodescode" to "anon";

grant insert on table "public"."nodescode" to "anon";

grant references on table "public"."nodescode" to "anon";

grant select on table "public"."nodescode" to "anon";

grant trigger on table "public"."nodescode" to "anon";

grant truncate on table "public"."nodescode" to "anon";

grant update on table "public"."nodescode" to "anon";

grant delete on table "public"."nodescode" to "authenticated";

grant insert on table "public"."nodescode" to "authenticated";

grant references on table "public"."nodescode" to "authenticated";

grant select on table "public"."nodescode" to "authenticated";

grant trigger on table "public"."nodescode" to "authenticated";

grant truncate on table "public"."nodescode" to "authenticated";

grant update on table "public"."nodescode" to "authenticated";

grant delete on table "public"."nodescode" to "service_role";

grant insert on table "public"."nodescode" to "service_role";

grant references on table "public"."nodescode" to "service_role";

grant select on table "public"."nodescode" to "service_role";

grant trigger on table "public"."nodescode" to "service_role";

grant truncate on table "public"."nodescode" to "service_role";

grant update on table "public"."nodescode" to "service_role";

grant delete on table "public"."organization" to "anon";

grant insert on table "public"."organization" to "anon";

grant references on table "public"."organization" to "anon";

grant select on table "public"."organization" to "anon";

grant trigger on table "public"."organization" to "anon";

grant truncate on table "public"."organization" to "anon";

grant update on table "public"."organization" to "anon";

grant delete on table "public"."organization" to "authenticated";

grant insert on table "public"."organization" to "authenticated";

grant references on table "public"."organization" to "authenticated";

grant select on table "public"."organization" to "authenticated";

grant trigger on table "public"."organization" to "authenticated";

grant truncate on table "public"."organization" to "authenticated";

grant update on table "public"."organization" to "authenticated";

grant delete on table "public"."organization" to "service_role";

grant insert on table "public"."organization" to "service_role";

grant references on table "public"."organization" to "service_role";

grant select on table "public"."organization" to "service_role";

grant trigger on table "public"."organization" to "service_role";

grant truncate on table "public"."organization" to "service_role";

grant update on table "public"."organization" to "service_role";

grant delete on table "public"."pasada" to "anon";

grant insert on table "public"."pasada" to "anon";

grant references on table "public"."pasada" to "anon";

grant select on table "public"."pasada" to "anon";

grant trigger on table "public"."pasada" to "anon";

grant truncate on table "public"."pasada" to "anon";

grant update on table "public"."pasada" to "anon";

grant delete on table "public"."pasada" to "authenticated";

grant insert on table "public"."pasada" to "authenticated";

grant references on table "public"."pasada" to "authenticated";

grant select on table "public"."pasada" to "authenticated";

grant trigger on table "public"."pasada" to "authenticated";

grant truncate on table "public"."pasada" to "authenticated";

grant update on table "public"."pasada" to "authenticated";

grant delete on table "public"."pasada" to "service_role";

grant insert on table "public"."pasada" to "service_role";

grant references on table "public"."pasada" to "service_role";

grant select on table "public"."pasada" to "service_role";

grant trigger on table "public"."pasada" to "service_role";

grant truncate on table "public"."pasada" to "service_role";

grant update on table "public"."pasada" to "service_role";

grant delete on table "public"."profile" to "anon";

grant insert on table "public"."profile" to "anon";

grant references on table "public"."profile" to "anon";

grant select on table "public"."profile" to "anon";

grant trigger on table "public"."profile" to "anon";

grant truncate on table "public"."profile" to "anon";

grant update on table "public"."profile" to "anon";

grant delete on table "public"."profile" to "authenticated";

grant insert on table "public"."profile" to "authenticated";

grant references on table "public"."profile" to "authenticated";

grant select on table "public"."profile" to "authenticated";

grant trigger on table "public"."profile" to "authenticated";

grant truncate on table "public"."profile" to "authenticated";

grant update on table "public"."profile" to "authenticated";

grant delete on table "public"."profile" to "service_role";

grant insert on table "public"."profile" to "service_role";

grant references on table "public"."profile" to "service_role";

grant select on table "public"."profile" to "service_role";

grant trigger on table "public"."profile" to "service_role";

grant truncate on table "public"."profile" to "service_role";

grant update on table "public"."profile" to "service_role";

grant delete on table "public"."provinces" to "anon";

grant insert on table "public"."provinces" to "anon";

grant references on table "public"."provinces" to "anon";

grant select on table "public"."provinces" to "anon";

grant trigger on table "public"."provinces" to "anon";

grant truncate on table "public"."provinces" to "anon";

grant update on table "public"."provinces" to "anon";

grant delete on table "public"."provinces" to "authenticated";

grant insert on table "public"."provinces" to "authenticated";

grant references on table "public"."provinces" to "authenticated";

grant select on table "public"."provinces" to "authenticated";

grant trigger on table "public"."provinces" to "authenticated";

grant truncate on table "public"."provinces" to "authenticated";

grant update on table "public"."provinces" to "authenticated";

grant delete on table "public"."provinces" to "service_role";

grant insert on table "public"."provinces" to "service_role";

grant references on table "public"."provinces" to "service_role";

grant select on table "public"."provinces" to "service_role";

grant trigger on table "public"."provinces" to "service_role";

grant truncate on table "public"."provinces" to "service_role";

grant update on table "public"."provinces" to "service_role";

grant delete on table "public"."roles" to "anon";

grant insert on table "public"."roles" to "anon";

grant references on table "public"."roles" to "anon";

grant select on table "public"."roles" to "anon";

grant trigger on table "public"."roles" to "anon";

grant truncate on table "public"."roles" to "anon";

grant update on table "public"."roles" to "anon";

grant delete on table "public"."roles" to "authenticated";

grant insert on table "public"."roles" to "authenticated";

grant references on table "public"."roles" to "authenticated";

grant select on table "public"."roles" to "authenticated";

grant trigger on table "public"."roles" to "authenticated";

grant truncate on table "public"."roles" to "authenticated";

grant update on table "public"."roles" to "authenticated";

grant delete on table "public"."roles" to "service_role";

grant insert on table "public"."roles" to "service_role";

grant references on table "public"."roles" to "service_role";

grant select on table "public"."roles" to "service_role";

grant trigger on table "public"."roles" to "service_role";

grant truncate on table "public"."roles" to "service_role";

grant update on table "public"."roles" to "service_role";

grant delete on table "public"."route_table" to "anon";

grant insert on table "public"."route_table" to "anon";

grant references on table "public"."route_table" to "anon";

grant select on table "public"."route_table" to "anon";

grant trigger on table "public"."route_table" to "anon";

grant truncate on table "public"."route_table" to "anon";

grant update on table "public"."route_table" to "anon";

grant delete on table "public"."route_table" to "authenticated";

grant insert on table "public"."route_table" to "authenticated";

grant references on table "public"."route_table" to "authenticated";

grant select on table "public"."route_table" to "authenticated";

grant trigger on table "public"."route_table" to "authenticated";

grant truncate on table "public"."route_table" to "authenticated";

grant update on table "public"."route_table" to "authenticated";

grant delete on table "public"."route_table" to "service_role";

grant insert on table "public"."route_table" to "service_role";

grant references on table "public"."route_table" to "service_role";

grant select on table "public"."route_table" to "service_role";

grant trigger on table "public"."route_table" to "service_role";

grant truncate on table "public"."route_table" to "service_role";

grant update on table "public"."route_table" to "service_role";

grant delete on table "public"."v_types" to "anon";

grant insert on table "public"."v_types" to "anon";

grant references on table "public"."v_types" to "anon";

grant select on table "public"."v_types" to "anon";

grant trigger on table "public"."v_types" to "anon";

grant truncate on table "public"."v_types" to "anon";

grant update on table "public"."v_types" to "anon";

grant delete on table "public"."v_types" to "authenticated";

grant insert on table "public"."v_types" to "authenticated";

grant references on table "public"."v_types" to "authenticated";

grant select on table "public"."v_types" to "authenticated";

grant trigger on table "public"."v_types" to "authenticated";

grant truncate on table "public"."v_types" to "authenticated";

grant update on table "public"."v_types" to "authenticated";

grant delete on table "public"."v_types" to "service_role";

grant insert on table "public"."v_types" to "service_role";

grant references on table "public"."v_types" to "service_role";

grant select on table "public"."v_types" to "service_role";

grant trigger on table "public"."v_types" to "service_role";

grant truncate on table "public"."v_types" to "service_role";

grant update on table "public"."v_types" to "service_role";

create policy "anon_restrict"
on "public"."barangays"
as restrictive
for all
to anon
using (false)
with check (false);


create policy "auth_restrict"
on "public"."barangays"
as restrictive
for all
to authenticated
using (false)
with check (false);


create policy "Enable insert for authenticated users only"
on "public"."driverlogs"
as permissive
for insert
to authenticated
with check (true);


create policy "restrict_all"
on "public"."municipalities"
as permissive
for all
to public
using (false)
with check (false);


create policy "Enable delete for users based on user_id"
on "public"."profile"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Enable insert for authenticated users only"
on "public"."profile"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable users to view their own data only"
on "public"."profile"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "can_update_own_data"
on "public"."profile"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


create policy "restrict_all"
on "public"."provinces"
as restrictive
for all
to public
using (false)
with check (false);


create policy "Users can view their classification based on profile.id"
on "public"."roles"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = ( SELECT auth.uid() AS uid))) = id));


CREATE TRIGGER add_driver_on_profile_update AFTER UPDATE OF role ON public.profile FOR EACH ROW EXECUTE FUNCTION insert_to_driver_table();


create schema if not exists "use";


